# entities.py
"""
Defines the classes for all entities in the simulation environment,
including Tasks, Vehicles, UAVs, and the Cloud Computing Center.
"""

import numpy as np

from config import *


class Task:
    """Represents a computational task generated by a vehicle."""

    def __init__(self, task_id, owner_vehicle_id):
        self.id = task_id
        self.owner_id = owner_vehicle_id
        self.data_size = np.random.uniform(*TASK_DATA_SIZE_RANGE)  # in Mbit
        self.cpu_cycles = np.random.uniform(*TASK_CPU_CYCLES_RANGE)  # cycles needed
        self.latency_constraint = np.random.uniform(*LATENCY_CONSTRAINT_RANGE)  # in seconds

    def __repr__(self):
        return f"Task(id={self.id}, size={self.data_size:.2f} Mbit)"


class Vehicle:
    """Represents a vehicle user in the simulation."""

    def __init__(self, vehicle_id):
        self.id = vehicle_id
        # --- FIX 1: Initialize position as a 3D vector [x, y, 0] ---
        pos_2d = np.random.rand(2) * np.array([AREA_WIDTH, AREA_HEIGHT])
        self.position = np.append(pos_2d, 0)
        # --- End of FIX 1 ---
        self.velocity = self._get_random_velocity()
        self.tasks = [Task(f"{self.id}-{i}", self.id) for i in range(TASKS_PER_VEHICLE)]

    def _get_random_velocity(self):
        """Generates a random velocity vector."""
        speed = np.random.uniform(VEHICLE_MIN_SPEED, VEHICLE_MAX_SPEED)
        angle = np.random.uniform(0, 2 * np.pi)
        # --- FIX 2: Velocity should also be 3D to match position ---
        return np.array([speed * np.cos(angle), speed * np.sin(angle), 0])
        # --- End of FIX 2 ---

    def move(self, timestep=1):
        """Updates the vehicle's position based on its velocity."""
        self.position += self.velocity * timestep
        # Implement boundary wrapping (toroidal world) for x and y
        self.position[0] %= AREA_WIDTH
        self.position[1] %= AREA_HEIGHT
        # z-coordinate remains 0

    def __repr__(self):
        return f"Vehicle(id={self.id}, pos={self.position})"


class UAV:
    """Represents a UAV acting as an edge server."""

    def __init__(self, uav_id, position=None):
        self.id = uav_id
        if position is None:
            # Random initial position
            pos_2d = np.random.rand(2) * np.array([AREA_WIDTH, AREA_HEIGHT])
            self.position = np.append(pos_2d, UAV_ALTITUDE)
        else:
            self.position = np.array(position)  # Expecting [x, y, z]

    def move(self, action):
        """
        Updates the UAV's position based on a move action.
        'action' could be a velocity vector, for example.
        This will be controlled by the RL agent in Phase 2.
        """
        # Placeholder for movement logic
        # For now, let's assume action is a 3D displacement vector
        self.position += action
        # Enforce boundaries
        self.position[0] = np.clip(self.position[0], 0, AREA_WIDTH)
        self.position[1] = np.clip(self.position[1], 0, AREA_HEIGHT)
        # Keep altitude constant for this simulation
        self.position[2] = UAV_ALTITUDE

    def __repr__(self):
        return f"UAV(id={self.id}, pos={self.position})"


class CloudComputingCenter:
    """Represents the central cloud server."""

    def __init__(self):
        self.id = "CCC"
        # The CCC has virtually unlimited resources. Its position is fixed and irrelevant.
